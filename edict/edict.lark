start: headers rules

headers: _header*
_header: header_default_field
       | header_case_insensitive_match
header_default_field: "default_field" field_name
header_case_insensitive_match: "case_insensitive_match" boolean_value
header_true_value: "true_value" string_value
header_false_falue: "false_value" string_value

rules: rule*
rule: "if" expression "then" assignments

// The record values processed by edict are represented as strings
// However, expressions in the edict language have a simple type system used for
// operator overloading.
// Possible types: string, number, boolean, pattern, record_value
// Record values are cast to/from other types automatically.
// Ambiguities are resolved in favour of strings.

identifier: WORD | FIELD_STRING
literal: QUOTED_STRING | NUMBER | BOOLEAN
match_literal: QUOTED_STRING | REGEX_STRING

atom: identifier | literal | LPAREN expression RPAREN

// Extension: Add casting as a function call
// primary: atom | call
// call: WORD "(" expression ")"
primary: atom

// Unary expression
// - :: Numeric negation
// + :: Numeric identity
u_expr: primary | PLUSMINUS u_expr

// Multiplication priority expression
m_expr: u_expr | m_expr "*" u_expr

// Addition priority expression
a_expr: m_expr | a_expr PLUSMINUS m_expr

// Comparison expression
comp_expr: a_expr COMPARISON_OP a_expr | a_expr "~" match_literal

// Logical not
not_expr: comp_expr | "!" comp_expr
// Logical and
and_expr: not_expr ( "&" not_expr )*
// Logical or
// At least one term but the first can optionally start with an operator
or_expr: and_expr _or_part* | _or_part+
_or_part: "|" and_expr | ":" match_literal

expression: or_expr

assignment: identifier expression
assignments: assignment*


// Tokens
// ======
WORD: /\w+/

// Quoted string and field string escape sequences
// \\ => \
// \} => }
// \a => ASCII bell
// \b => ASCII backspace
// \f => ASCII form feed
// \n => ASCII line feed
// \r => ASCII carriage return
// \t => ASCII horizontal tab
// \v => ASCII vertical tab
// \xhh => Character with hex value hh
// \uxxxx => Character with 16-bit hex value xxxx
// \Uxxxxxx => Character with 32-bit hex value xxxxxx
QUOTED_STRING: "\"" /(?:[^"\\]|\\.)*/ "\""
FIELD_STRING: "{" /(?:[^\/}]|\\.)*/ "}"
// Regex string escape sequences: \/ => / (plus all python regex escapes)
REGEX_STRING: "/" /(?:[^\/\\]|\\.)*/ "/"

%import common.NUMBER
BOOLEAN: TRUE | FALSE
FALSE: "false"
TRUE: "true"

PLUSMINUS: PLUS | MINUS
PLUS: "+"
MINUS: "-"

COMPARISON_OP: EQ | NE | LT | LE | GT | GE
EQ: "="
NE: "!="
LT: "<"
GT: ">"
LE: "<="
GE: ">="

// Ignores
%import common.WS
%ignore WS

COMMENT: "#" /[^\n]/*
%ignore COMMENT
